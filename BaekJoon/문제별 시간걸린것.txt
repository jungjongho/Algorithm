12100_2048:

0이 2칸이 있을떄 한번에 미는 방법을 찾는것이 꽤나 고민이었음

단순히 재귀가아니라 행렬의 크기만큼 반복해서 당기는것으로 해결 하지만 효율성 문제가있는듯

2차원 리스트는 단순한 copy가 아니라 deepcopy함수를 사용해야지 copy가 됨

copy만으로는 안의 리스트 주소를 가져와서 copy된 2차원 행렬이 변화할때 그안의 리스트가 같이 변화하는듯(여기서 머리좀썩임)



===================================================================================================================================================================================================================================================================================


13458

단순한 수학적 계산이라 처음 코드를 짜는데는 오래걸리지 않았다 하지만 생각지도 못하게 계속 틀린 반례가 나온것이다.

어디서 나왔을까 곰곰히 생각해봤다.

주 감독관이 허용할수 있어서 학생들의 수가 음수가 되는 부분을 캐치하지 못한것이다.

꽤나 생각지 못한곳에서 터졌던 것이다. 

반례를 찾는 과정 -> 감독관당 3가지 케이스로 생각했따.

1. 학생수가 주감독관 혼자서 못하는겨우
2. 학생수가 주감독관 혼자서 딱 맞는경우
3. 학생수가 주감독관 혼자서 하고도 남는경우

1,2,3케이스에서 1,2,케이스에서 부감독관이 하는것과 딱맞는 경우와 남는경우 2가지로 나누어서 총 5가지 케이스에대해서 예시를 대입해봤을때

3번케이스에서 오류가 나타남을 알수있었다. 정답률이 꽤 낮은 문제였는데 어렵다기보다 3번 예시를 찾지못해서 사람들이 넘어간듯 하다.


==================================================================================================================================================================================================================================================================================


13460_bead_escape: 

반복되는 리스트의 원소들 ex)[up,up,up,up,up,down,right,down,right]로 되어있는걸 up,down,right,down,right로 어떻게 바꾸는가?

바꾸는데 성공했지만 역시 10번이하의 시도 가능한 연산들을 전부 모으는 경우는 너무나 비효율적인것 같다 총 10회 이하로 생각했을때

4^10번을 생각 해야하니 말이다. 차라리 시도하는 도중에 빠져나오게 하는것이 훨씬더 좋을것 같다는 생각이다.


모든 경우의수에서 도중에 빠져나오는 코드를 짜려했지만 이또한 결국 4^10을 생각해야해서 아예 포기하기로한다.

그래서 다른 사람의 코드를 참고해보려한다.

참고: https://rebas.kr/725 [PROJECT REBAS]

이는 전체적인 상황을 설계할때 어떤식으로 했는지 dfs를 어떻게 활용했는지 알수있어서 좋았다. 

그리고 새로운 문법을 하나 알았는데 
1. [ [0] * n for _ in range(m) ]

2. [ [0] * n ] * m

두개의 표현이 다르다는 것이다.  1번의 경우 각원소 0이 개별적으로 움직이는 반면

2번의 경우 하나의 0이 변화하면 다른 좌표를 가진 0들도 변화한다. 

ex)
a = [[0] * 2] * 3
b = [[0] * 2 for _ in range(3)]

a[0][0] = 1
b[0][0] = 1

print(a)
print(b)

# 출력
[[1, 0], [1, 0], [1, 0]]
[[1, 0], [0, 0], [0, 0]]
===================================================================================================================================================================================================================================================================================
14499_dice

주사위가 움직일때의 규칙성을 파악해서 코드를 짜는게 제일 귀찮았던 문제

분명 내 로컬환경에서는 잘돌아가는데 

채점을 맡기면  type error가 뜬다 아직 이유는 모름


=========================================================================================================================================================================================================================================================================

14500_tet:

일단 시작은 블록의 기준을 잡고 경우의수를 나누어서 점수의 합을 구하려한다.

코드길이가 상당히 길었던 문제 문제가 어렵다기 보다는 경우의수를 일일이 나눠서 제시하는것이 귀찮았던것 같다.


===================================================================================================================================================================================================================================================================================


14501_Leave:

다이나믹 프로그래밍 문제를 처음 풀어봤다. 결국 혼자 해결하기에 시간이 걸려 다른 분의 코드를 참고했는데

1. 새로운 리스트를 만들고 거기에 그동안의 로그를 남기는 생각이 굉장히 놀라웠다.

2. 남은 work를 앞에서부터 세는것이 아니라 뒤에서 세었다. 어찌보면 당연하다고 생각했지만 그것에 대한 구현이 생각보다 간단해 놀랐다. 

아무래도 파이썬 기본 문법실력이 아주 처참하다는 것을 깨닫는 문제중 하나였다.


===================================================================================================================================================================================================================================================================================


14502_virus:
오랜만에 재귀를 사용 
재귀를 사용할때는 조건 하나에따라 연산의 갯수가 많이 달라지므로 가장 효율적인(좁은) 조건을 찾는것이 포인트라고 할수있을것이다.

===================================================================================================================================================================================================================================================================================
14503_robot_cleaner:

슬슬 좌표와 visit을 이용한 문제중 쉬운문제는 어떻게 푸는지 대략 보이기 시작했다.


===================================================================================================================================================================================================================================================================================



14888_operation_insert:

중복제거의 경우는 set자료를 사용할것 
동적으로 변화하는 number리스트를 해결하는것이 포인트지 않았나 함




===================================================================================================================================================================================================================================================================================



14889_start_link:
상대편 팀을 구할때 set의 차집합을 사용
굳이 team1과 team2를 나누지 않는다면 연산 속드를 50%감소 할수 있을것 같은데 명시하지않고 자료들을 표현하는 방법이 무엇이 있을까...





===================================================================================================================================================================================================================================================================================

15684_ladder:

꽤나 잘 짰다고 생각했지만 시간초과로 인해 실패... 어디에서 좀더 효율성을 찾을수 있을것인가...

cas1234kr@

1811-8585

760-1055

